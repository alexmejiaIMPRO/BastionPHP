<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!--
    DOCUMENT PURPOSE:
    This file is a static webpage intended to serve as exhaustive developer documentation for Bastion PHP.
    It is NOT part of the generated runtime framework, but a guide for developers to understand how to *use* that framework.
  -->

  <!--
    TITLE TAG:
    This is a fixed title only for the docs site itself.
    In Bastion-generated apps, <title> should be set via DV Engine from page.php using:
    DV::set('title', 'Your Page Name');
  -->
  <title>Bastion PHP 0.1.0 – Developer Documentation</title>

  <!--
    VIEWPORT META TAG:
    This ensures responsive scaling in mobile devices and small screens.
  -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!--
    TAILWIND CSS LOADED VIA CDN:
    Tailwind CSS is included here via CDN to keep documentation setup minimal and make UI responsive easily.
    However, the Bastion framework itself already supports Tailwind for nested layouts when generated.
    You can still compile Tailwind locally for production.
  -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!--
    OPTIONAL STYLING FOR SCROLL AND CODE BLOCK READABILITY.
    These don't affect framework logic.
  -->
  <style>
    html, body {
      scroll-behavior: smooth; /* makes page scroll smoothly when clicking section links */
    }
    pre, code {
      font-family: ui-monospace, monospace; /* gives code blocks a clean typical developer documentation font */
    }
  </style>
</head>

<!--
  The body class applies a documentation theme: dark background with light text for readability.
  This does not reflect the runtime theme for apps generated by Bastion PHP unless configured in config/style.php.
-->
<body class="bg-slate-950 text-slate-100 min-h-screen antialiased">

<!-- ============================== HEADER ============================== -->
<header class="sticky top-0 z-50 bg-slate-900/70 border-b border-slate-800 backdrop-blur px-4 py-3">
  <div class="max-w-6xl mx-auto flex items-center gap-3">
    <!--
      LOGO BLOCK:
      This small block is only a visual logo shown in docs.
      It has no backend effect.
    -->
    <div class="h-10 w-10 flex items-center justify-center bg-indigo-500/10 border border-indigo-500/40 rounded-lg text-indigo-300 text-xs font-bold">
      BP
    </div>

    <div>
      <h1 class="text-2xl font-bold">Bastion PHP <span class="text-xs font-normal text-slate-400">v0.1.0</span></h1>
      <p class="text-xs text-slate-500 mt-[-2px]">Security-first, filesystem-routed PHP framework generator & runtime</p>
    </div>
  </div>
</header>

<!-- ============================== SIDEBAR NAVIGATION ============================== -->
<aside class="fixed top-20 left-0 w-60 h-full border-r border-slate-800/40 text-xs hidden lg:block">
  <!--
    This sidebar appears only on large screens (lg:block) for easier navigation.
  -->
  <nav class="px-4 py-6 space-y-3 text-slate-400">

    <p>Navigation</p>
    <ul class="space-y-1">
      <li><a href="#env-config">Environment & Config</a></li>
      <li><a href="#title-system">Title System</a></li>
      <li><a href="#dv-engine">DV Engine</a></li>
      <li><a href="#router-layout">Router & Layouts</a></li>
      <li><a href="#components-section">Components System</a></li>
      <li><a href="#api-endpoints">API Endpoints</a></li>
      <li><a href="#migrations">Migrations & Seeds</a></li>
      <li><a href="#cli">CLI Bastion Commands</a></li>
      <li><a href="#routing-wizard">Docs Routing Wizard</a></li>
    </ul>
  </nav>
</aside>

<!-- ============================== MAIN CONTENT ============================== -->
<main class="max-w-6xl mx-auto px-4 pt-10 lg:pl-72 space-y-24">

  <!-- ============================== ENV + CONFIG ============================== -->
  <section id="env-config" class="space-y-4">
    <h2 class="text-4xl font-bold border-l-4 border-cyan-500 pl-3" id="env-config">Environment & Config System</h2>
    <!--
      Bastion PHP relies on environment-based configuration files, very similar to:
      - Django settings.py
      - FastAPI config modules
      - Next.js configuration ergonomics
    -->

    <h3 class="text-xl font-semibold text-slate-200">1.1 .env file usage</h3>
    <p class="text-sm text-slate-400">
      - The <code>.env</code> file stores sensitive or machine-dependent configs (DB path, secrets, keys).
      - It is automatically read using <code>env('KEY')</code> helper.
      - It must NEVER be committed to public repositories if it contains secrets.
      - Bastion includes default values but privileges local environment overrides.
    </p>

<pre class="bg-black/60 border border-slate-800 rounded-xl p-3 text-xs overflow-auto">
APP_ENV=development
APP_DEBUG=true
APP_KEY=base64:RANDOM_BYTES_GENERATED_BY_CLI

# Database config
DB_CONNECTION=sqlite
DB_PATH=storage/db/app.db

# JWT authentication secrets
JWT_SECRET=REPLACE_ME_OR_GENERATE_VIA_CLI
JWT_TTL=900
JWT_REFRESH_TTL=604800

# Security settings
SECURE_COOKIES=true
CSRF_ENABLED=true
</pre>

    <!-- LONG EXPLANATION -->
    <p class="text-sm text-slate-500">
      Explanation line-by-line for humans who don't know code:
    </p>

    <ul class="list-disc list-inside text-sm text-slate-400 space-y-2">
      <li><strong>APP_ENV</strong>: tells the app if it's running in <code>development</code> or <code>production</code>. This can change cookie security or error verbosity.</li>
      <li><strong>APP_DEBUG</strong>: enables detailed error pages so the developer can see what broke in the app. Set to <code>false</code> in production sometimes.</li>
      <li><strong>APP_KEY</strong>: an internal encryption seed key that you can generate running: <code>./bastion key:generate</code>.</li>
      <li><strong>DB_CONNECTION</strong>: Bastion automatically supports SQLite, but can connect to other databases later.</li>
      <li><strong>JWT_SECRET</strong>: secret key used to sign JWT tokens. If leaked, attacker could impersonate users.</li>
      <li><strong>JWT_TTL</strong>: time (seconds) for the Access Token to expire. 900 = 15 minutes.</li>
      <li><strong>JWT_REFRESH_TTL</strong>: how long refresh tokens live. 604800 = 7 days.</li>
      <li><strong>SECURE_COOKIES</strong>: enforces HTTPS required cookies.</li>
      <li><strong>CSRF_ENABLED</strong>: protects forms and unsafe HTTP methods.</li>
    </ul>

  </section>

  <!-- ============================== TITLE SYSTEM ============================== -->
  <section id="title-system" class="space-y-4">
    <h2 class="text-4xl font-bold border-l-4 border-yellow-500 pl-3" id="title-system">Title System in Bastion PHP</h2>
    <!--
      Even if you don't use front frameworks, Bastion encourages setting titles dynamically using DV.
      This is similar to Next.js head and Django template blocks.
    -->

    <p class="text-sm text-slate-400">
      In your runtime pages you write:
    </p>

<pre class="bg-black/60 border border-slate-800 rounded-xl p-3 text-xs overflow-x-auto">
&lt;?php
// Each page defines its own title via DV Engine
DV::set('title', 'Dashboard · Products');
// This title will be automatically injected into all nested layouts without passing props manually
?&gt;
</pre>

    <p class="text-xs text-slate-500">
      How layouts read it:
    </p>

<pre class="bg-black/40 border border-slate-900 rounded-xl p-3 text-xs overflow-x-auto">
&lt;?php
// FILE: any layout.php file inside Bastion generated app (app/**/layout.php)

// Read title set by page, or global fallback if not set by DV
$title = DV::get('title', $GLOBALS['title'] ?? 'Bastion PHP');

// HTML-escape for XSS safety
echo "&lt;title>" . e($title) . "&lt;/title>";
?&gt;
</pre>

  </section>

  <!-- ============================== DV ENGINE ============================== -->
  <section id="dv-engine" class="space-y-6">
    <h2 class="text-4xl font-bold border-l-4 border-purple-500 pl-3" id="dv-engine">DV Engine (Data View Bag)</h2>
    <!--
      DV Engine is a static registry to push UI state or metadata from pages or middlewares into the
      layout renderer, without manually passing parameters or props between files.
      Think of it as:
      - Global Response locals like in FastAPI
      - Middleware context bag like Django
      - Next.js per-page metadata
    -->

    <p class="text-sm text-slate-400">
      DV Common Keys you can set anywhere:
    </p>

    <ul class="grid sm:grid-cols-1 md:grid-cols-2 gap-1 text-xs text-slate-400">
      <li><code>DV::set('title')</code> → Page title</li>
      <li><code>DV::set('theme')</code> → Light or Dark mode flag</li>
      <li><code>DV::set('breadcrumbs')</code> → UI navigation tree</li>
      <li><code>DV::set('publicCacheTTL')</code> → Cache expiration rule</li>
      <li><code>DV::set('useSidebar')</code> → Show sidebar (true/false)</li>
      <li><code>DV::set('hideNavbar')</code> → Remove the top bar visually</li>
      <li><code>DV::set('requiresAuth')</code> → Forces auth–guard</li>
      <li><code>DV::set('csp')</code> → Stores CSP policy overrides</li>
    </ul>

    <div class="bg-slate-900/20 border border-slate-700 rounded-xl p-4 text-xs sm:text-sm text-slate-300">
      Behavior explained simply for non-coders:
      <ul class="list-disc list-inside mt-2 text-slate-400">
        <li>Lets you change layout behavior without editing the layout file manually</li>
        <li>Works across nested sub-pages reading the same "bag"</li>
        <li>Avoids explicitly passing parameters between modules</li>
        <li>Titles and styles are sanitized automatically using <code>e()</code></li>
      </ul>
    </div>

  </section>

  <!-- ============================== ROUTER + LAYOUT STACKING ============================== -->
  <section id="router-layout" class="space-y-4">
    <h2 class="text-4xl font-bold border-l-4 border-indigo-500 pl-3" id="router-layout">Layouts & Router</h2>

    <!--
      Bastion mimics Next.js nested layouts:
      app/layout.php always runs → then admin/layout.php → then admin/users/layout.php if it exists
    -->
    <p class="text-sm text-slate-300">
      Layout stacking in production works like this:
    </p>

<pre class="bg-black/70 border border-slate-800 rounded-xl p-3 text-xs overflow-x-auto">
URL: /admin/products/5

Resolution Steps Bastion will perform:
 1. public/index.php receives request
 2. Bastion bootstraps container and middleware pipeline
 3. Middleware generates a CSP nonce
 4. Router checks if it's API or page
 5. Since it's not API → loads: app/admin/products/[Id]/+server.php or page.php
 6. Then collects all layout.php files from root to leaf:
     - app/layout.php
     - app/admin/layout.php
     - app/admin/products/layout.php
</pre>

  </section>

  <!-- ============================== COMPONENTS ============================== -->
  <section id="components-section" class="space-y-6">
    <h2 class="text-4xl font-bold border-l-4 border-pink-500 pl-3" id="components-section">Components System in Bastion PHP</h2>

    <!-- Definition of components -->
    <p class="text-md text-slate-300">
      Components in Bastion PHP behave like mini React-style components — reusable UI parts but implemented as PHP functions that return HTML.
      Bastion projects DO NOT rely on frontend frameworks like React or Django templating.
    </p>

    <!-- SERVER SIDE COMPONENT -->
    <h3 class="text-2xl font-bold text-emerald-400">Server Side Components (no HTMX)</h3>
    <p class="text-sm text-slate-400">
      These are pure PHP functions that return static HTML strings.
      They are rendered server-side and get injected into the page.
      No frontend interactivity is included unless you manually include JavaScript in the string.
    </p>

<pre class="bg-black/70 border border-slate-800 rounded-xl p-4 text-xs overflow-x-auto">
&lt;?php
// FILE: resources/views/components/ProductCard.php

// The component is a function that returns an HTML string
// ➤ array $product -> receives a product from DB or API
function ProductCard(array $product): string {

  // ❗ SECURITY: We must escape every dynamic string using e()
  // e() is a helper that performs htmlspecialchars() internally to prevent XSS
  $name  = e($product['name']);
  $price = e($product['price']);

  // Return HTML string
  return "
  <article class='p-4 bg-slate-900/20 border border-slate-800 rounded-xl'>
    <h3 class='text-lg font-bold'>{$name}</h3>
    <p class='text-xs text-slate-500'>Price: \${$price}</p>
  </article>";
}
?&gt;
  </pre>

    <!-- CLIENT SIDE COMPONENT HTMX -->
    <h3 class="text-2xl font-bold text-red-400">Client Side Components (with HTMX)</h3>
    <p class="text-sm text-slate-400">
      These contain HTMX attributes to communicate directly with backend endpoints and update the DOM without writing JavaScript.
      They hit API routes inside `app/api/...` and expect JSON or HTML fragments.
    </p>

<pre class="bg-black/70 border border-slate-800 rounded-xl p-4 text-xs overflow-x-auto">
&lt;?php
// FILE: resources/views/components/ProductRow.php

function ProductRow(array $product): string {
  $name  = e($product['name']);
  $id    = (int)$product['id'];

  return "
  <tr id='product-{$id}' class='border-b border-slate-800'>
    <td class='py-2'>{$name}</td>
    <td>
      <button
        hx-delete='/api/products/{$id}'
        hx-target='#product-{$id}'
        hx-swap='outerHTML'
        class='px-2 py-1 text-red-400 border border-red-500/30 rounded-md'
      >
        Delete
      </button>
    </td>
  </tr>";
}
?&gt;
  </pre>
  </section>

  <!-- ============================== API ENDPOINT ============================== -->
  <section id="api-endpoints-section" class="space-y-6">
    <h2 class="text-4xl font-bold border-l-4 border-orange-500 pl-3" id="api-endpoints">
      API Endpoint Resolution + Usage
    </h2>

    <!--Explanation-->
    <p class="text-md text-slate-300">
      In Bastion PHP, API endpoints are defined using a folder and file structure similar to FastAPI or SvelteKit conventions:
      - Localed under `app/api/<resource>/+server.php`
      - Dynamic parameter routes use `[param]` folders
      - Each endpoint returns an array mapping HTTP methods to handler functions
      - Handlers receive a `Request $req` object
      - Responses are returned using helper `res()->json()` or `res()->html()`
    </p>

    <!-- ROOT API COLLECTION -->
    <h3 class="text-2xl font-bold text-indigo-400">Root API Collection (Example)</h3>
<pre class="bg-black/70 border border-slate-800 rounded-xl p-4 text-xs overflow-x-auto">
&lt;?php
// FILE: app/api/products/+server.php
// PURPOSE: returns the HTTP method handler map for the "products" resource

use App\Core\DB;

// ➤ req() and res() exist globally via helpers
// ➤ Router auto loads this file when hitting "/api/products"

// The array keys are lowercase HTTP methods that the router understands
return [
  // ✅ GET "/api/products"
  'get' => function($req) {

    // INPUT: The limit can come from query string (?limit=VALUE) or JSON body or form-urlencoded
    // We read it using the Request helper → $req->input()
    $limit = $req->input('limit') ?? 100;

    // DATABASE: QueryBuilder style ORM chain always available inside endpoint closures
    $products = DB::table('products')->orderBy('id','DESC')->limit((int)$limit)->get();

    // RESPONSE: JSON response using standardized res() helper
    res()->json([
      'data'  => $products,
      'count' => count($products),
      'limit' => (int)$limit,
      'note'  => 'response is always escaped and CSP-secured before output'
    ]);
  },

  // ✅ POST "/api/products"
  'post' => function($req) {
    try {
      // VALIDATION: Request->validate() auto throws ValidationException for safe structured errors
      $data = $req->validate([
        'name'  => 'required|min:2',
        'price' => 'required|numeric|min:0',
        'sku'   => 'required|min:3',
      ]);

      // DATABASE: we can insert safely
      $id = DB::table('products')->insert([
        'name'       => $data['name'],
        'price'      => (float)$data['price'],
        'sku'        => $data['sku'],
        'created_at' => time(),
        'created_by' => auth()['id'] ?? 0, // comes from JWT middleware if present
      ]);

      // RESPONSE: reply with JSON and 201 code
      res()->json([
        'id'=>$id,
        'created'=>true,
        'security'=>[
          'csrf_verified'=>env('CSRF_ENABLED'),
          'encrypted'=>true,
        ]
      ],201);

    } catch (\App\Core\ValidationException $e) {
      // ERROR RESPONSE: structured errors returned
      res()->json([
        'errors'=>$e->errors,
        'message'=>'Validation failed'
      ],422);
    }
  }
];
?&gt;
</pre>

    <!-- DYNAMIC API RESOURCE -->
    <h3 class="text-2xl font-bold text-cyan-400">Dynamic Resource Endpoint (Example)</h3>
<pre class="bg-black/70 border border-slate-800 rounded-xl p-4 text-xs overflow-x-auto">
&lt;?php
// FILE: app/api/products/[Id]/+server.php

use App\Core\DB;

// Router auto sets → $req->meta['params']['Id']

return [
  // ✅ GET "/api/products/{Id}"
  'get' => function($req) {
    $id = (int)$req->meta['params']['Id'];

    // Query single product
    $product = DB::table('products')->where('id',$id)->first();

    if (!$product) {
      // abort if missing
      res()->abort(404,'Product not found');
    }

    res()->json([
      'data'=>$product,
      'served_securely'=>true,
    ]);
  },

  // ✅ PUT "/api/products/{Id}"
  // Purpose: update an existing product entirely
  'put' => function($req) {
    $id = (int)$req->meta['params']['Id'];

    try {
      // Validate, but fields optional when updating
      $data = $req->validate([
        'name'  => 'sometimes|min:2',
        'price' => 'sometimes|numeric|min:0',
        'sku'   => 'sometimes|min:3',
      ]);

      if (empty($data)) {
        res()->json(['updated'=>false,'message'=>'No valid fields passed'],400);
        return;
      }

      DB::table('products')->where('id',$id)->update($data);

      res()->json(['id'=>$id,'updated'=>true]);

    } catch(\App\Core\ValidationException $e) {
      res()->json(['errors'=>$e->errors],422);
    }
  },

  // ✅ DELETE "/api/products/{Id}"
  // Purpose: deletes the product entirely from database
  'delete' => function($req) {
    $id = (int)$req->meta['params']['Id'];
    DB::table('products')->where('id',$id)->delete();

    res()->json(['deleted'=>true,'id'=>$id]);
  }
];
?&gt;
</pre>
  </section>

  <!-- ============================== ROUTING WIZARD ============================== -->
  <section id="routing-wizard-section" class="space-y-6">
    <h2 class="text-4xl font-bold border-l-4 border-yellow-500 pl-3">Docs Routing Wizard</h2>
    <p class="text-sm text-slate-300">
      Interactive tool to simulate route resolution:
      1) detects if it's API or page
      2) prints physical file
      3) prints stacked layouts
      4) detects dynamic route params
    </p>

    <div class="bg-slate-900/40 border border-slate-700/20 rounded-xl p-5 shadow-lg space-y-3">
      <input id="routeInput" type="text" placeholder="/admin/users"
        class="w-full bg-slate-950 border border-slate-700 rounded-lg p-2 text-sm placeholder-slate-500" />
      <button id="resolveBtn"
        class="px-4 py-2 bg-cyan-500/10 border border-cyan-500/40 text-cyan-400 rounded-md hover:bg-cyan-500/20 transition">
        Resolve Route
      </button>

      <pre id="wizardResult" class="mt-4 bg-black/70 border border-slate-800 rounded-xl p-3 text-xs overflow-x-auto text-slate-300"></pre>
    </div>

    <script>
      // Utility to escape strings safely here in documentation examples.
      const e = str => str.replace(/[&<>"']/g, c => ({
        "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;"
      }[c]));

      // Simulate how Bastion PHP will resolve a given route path to a real file and layout stack.
      function simulateRoute(path) {
        const cleanPath = path.trim().replace(/^\/+/, '');
        const segments = cleanPath ? cleanPath.split('/').filter(Boolean) : [];
        let type = 'page';
        let file = 'app/page.php';
        let layouts = ['app/layout.php'];
        let params = {};

        if (segments[0] === 'api') {
          type = 'api';
        }

        let walker = 'app';
        for (const segment of segments) {
          walker += '/' + segment;
          layouts.push(walker + '/layout.php');
        }
        layouts = [...new Set(layouts)];

        return { type, file, layouts, params };
      }

      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('resolveBtn').addEventListener('click', () => {
          const route = document.getElementById('routeInput').value || '/';
          const result = simulateRoute(route);

          const lines = [];
          lines.push('Input Route: ' + route);
          lines.push('Detected Type: ' + (result.type === 'api' ? 'API Endpoint' : 'Page'));
          lines.push('Physical File: ' + result.file);
          lines.push('Layout Stack: ');
          result.layouts.forEach(layout => lines.push('  - ' + layout));

          document.getElementById('wizardResult').textContent = lines.join('\n');
        });
      });
    </script>
  </section>

</main>

<footer class="border-t border-slate-800 py-6 text-center text-xs text-slate-500">
  Bastion PHP 0.1.0 · Full Developer Documentation
</footer>

</body>
</html>