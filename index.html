<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Bastion PHP 0.1.0 – Developer Documentation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Tailwind fully via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body { scroll-behavior: smooth; }
    pre, code { font-family: ui-monospace, monospace; }
  </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen">

<header class="border-b border-slate-800 bg-slate-900/80 px-4 py-3 sticky top-0 z-40 backdrop-blur">
  <div class="max-w-6xl mx-auto flex items-center gap-3">
    <div class="h-8 w-8 bg-blue-500/10 border border-blue-500/40 text-blue-400 flex items-center justify-center rounded-lg text-xs font-semibold">BP</div>
    <div>
      <h1 class="text-lg font-bold">Bastion PHP <span class="text-xs font-normal text-slate-400">v0.1.0</span></h1>
      <p class="text-xs text-slate-400">A secure, fast, zero-magic PHP framework</p>
    </div>
  </div>
</header>

<main class="max-w-6xl mx-auto px-4 py-8 space-y-12">

<!-- OVERVIEW -->
<section class="space-y-6">
  <h2 class="text-3xl font-bold" id="overview">Overview</h2>

  <p class="text-base text-slate-300">
    Bastion PHP is a <strong>framework generator + runtime engine</strong> that produces a secure app scaffold with:
    <strong>Next.js-style filesystem routing</strong>, <strong>FastAPI-like `+server.php` endpoints</strong>, 
    a <strong>PDO QueryBuilder ORM-like facade</strong>, DV engine for state-sharing, and HTML components that behave similarly to
    React components (server and client interactive via HTMX).
  </p>

  <div class="bg-slate-950/60 border border-slate-800 rounded-2xl p-5 text-sm">
    Key guarantees:
    <ul class="list-disc list-inside mt-2 space-y-1 text-slate-400">
      <li>Security always enabled (CSP nonce, CSRF, SameSite, HttpOnly)</li>
      <li>SQLite + WAL default for concurrency</li>
      <li>No frameworks in front, no template engines, no silent errors</li>
      <li>Readable viewport: code is the documentation</li>
    </ul>
  </div>
</section>

<!-- PROJECT STRUCTURE -->
<section class="space-y-4">
  <h2 class="text-3xl font-bold" id="structure">Generated Structure</h2>
  <p class="text-slate-400 text-sm">
    What the generator scaffolds is opinionated and extremely modular. Here is the blueprint and what each layer is for:
  </p>

  <pre class="bg-slate-950/80 border border-slate-800 rounded-xl p-4 overflow-x-auto text-xs">
app/                        → All routable features & API resources.
  layout.php                → Root HTML shell. Injects <title> from DV and defines global <script nonce> & components.
  page.php                  → Route "/" page body. Only prints the inner content (HTML fragment), no <html/head>.
  Core/                    → Framework foundation (container + facades):
    App.php                → Bootstraps container, session, middlewares, router dispatch.
    Router.php             → Filesystem router. Supports static pages, [param] folders, and +server.php endpoints.
    DB.php                → PDO wrapper + QueryBuilder. Facade-like chains. Holds WAL pragmas for SQLite.
    DV.php                → Data View Engine. Used to set layout state (e.g., title, breadcrumbs, flags).
    Request.php           → Normalized HTTP request payload. Central input parser + validation errors.
    Response.php          → Response utilities (JSON, HTML, redirects, abort codes).
    Auth.php              → JWT handling + DB refresh tokens rotation + role helpers.
    CSRF.php              → Token issue & compare. Middleware uses this for unsafe methods.
    Logger.php             → Structured logging. Writes to storage/logs/app.log.
    Theme.php             → UI flags like dark/light toggle, structured CSS helpers.
    helpers.php             → Global security helpers e(), env(), auth(), logger(), csrf_token(), csrf_field()...
  Middleware/              → Wrappers that enforce security before routing:
    SecurityHeaders.php   → Creates CSP nonce, X-Frame-Options, NoSniff, Coco-enforced script blocking.
    RateLimit.php         → Stub for throttling API or IP quotas (ready for extension).
    AuthMiddleware.php     → Injects user from JWT & CSRF compare if enabled.
    AdminOnly.php         → Guard for admin modules or sensitive routes.
  Models/                  → Domain models (server side business entities, no HTML, pure PHP):
    User.php              → Static model. Has find, findByEmail, all, create, updateUser, deleteUser.
  Services/                → Place for your own business services, external API connectors, adapters.
  admin/                   → Routable admin module, Next.js-like layout inheritance.
  login/                   → Shows form, uses csrf_field(), POSTs to /api/auth/login
  logout/                  → Clears cookies, can call Response::json() or redirect.
public/
  index.php                → Front controller. Entry point of every HTTP request.
public/css/fallback.css    → Minimal CSS if CDN styles aren't used in prod.
database/
  migrations/*.sql         → Plain SQL migrations executed sequentially.
  seeds/*.php             → Seeders that hydrate default users/parts/calibrations.
storage/
  db/app.db               → SQLite file created by generator.
  logs/app.log             → Framework logs.
bastion                    → CLI commands: run-dev, build, migrate, seed, make:* scaffolding...</pre>
</section>

<!-- DV ENGINE -->
<section class="space-y-4">
  <h2 class="text-3xl font-bold" id="dv">DV Engine (Data View)</h2>
  <p class="text-slate-400">
    DV allows pages to push layout state into a shared “view bag” readable by layouts, API endpoints, or components.
    It is the recommended way to set structural parameters like <strong>page titles</strong> or <strong>UI flags</strong>.
  </p>

  <div class="bg-slate-950/60 border border-slate-800 rounded-2xl p-5 text-sm text-slate-300">
    <strong>Why DV::set('title', ...) matters:</strong>
    <ul class="list-disc list-inside mt-2">
      <li>All layouts call <code>$title = DV::get('title', 'Fallback')</code> to render <code>&lt;title&gt;</code></li>
      <li>You never manually echo or pass <code>$title</code> into nested layouts</li>
      <li>Breadcrumbs, admin flags, and screen metadata can be stored the exact same way</li>
    </ul>
  </div>

  <pre class="bg-slate-950/80 rounded-xl p-4 text-xs overflow-x-auto"><code>&lt;?php
// In a page:
DV::set('title', 'Admin · Users');
DV::set('breadcrumbs', ['Admin', 'Users']);
DV::set('hideSidebar', false);

// In any layout:
$title = DV::get('title', $GLOBALS['title'] ?? 'Bastion PHP');
echo "&lt;title&gt;" . e($title) . "&lt;/title&gt;";</code></pre>

  <p class="text-sm text-slate-400">
    Notice: layouts sanitize output using <code>e()</code> to prevent XSS or HTML injection.
  </p>
</section>

<!-- QUERYBUILDER ORM -->
<section class="space-y-4">
  <h2 class="text-3xl font-bold" id="db">DB Layer & QueryBuilder (ORM-like chains)</h2>

  <p class="text-base text-slate-300">
    Bastion never hides SQL from you. It wraps PDO and simulates Django/FastAPI model ergonomics:
  </p>

  <ul class="list-disc list-inside text-slate-400 text-sm space-y-1 mb-3">
    <li><code>DB::table('users')->where('role','admin')->limit(10)->get()</code></li>
    <li><code>DB::table('parts')->insert([...])</code></li>
    <li><code>DB::table('calibrations')->where('id',$id)->update([...])</code></li>
  </ul>

  <div class="bg-slate-950/60 border border-slate-800 rounded-2xl p-5 text-sm text-slate-300">
    <strong>Concurrency Best Practices (SQLite default):</strong>
    <ul class="list-disc list-inside mt-2">
      <li>Database created with WAL for parallel writes</li>
      <li><code>PRAGMA journal_mode=WAL;</code> always enabled internally by DB service</li>
      <li>Use <code>first()</code> instead of <code>get()</code> if you only expect one row</li>
      <li>Every value echo'd into HTML must pass through <code>e()</code> or <code>htmlspecialchars()</code></li>
    </ul>
  </div>
</section>

<!-- COMPONENTS LIKE REACT -->
<section class="space-y-6">
  <h2 class="text-3xl font-bold" id="components">Components (Server-Side &amp; Client-Interactive)</h2>

  <p class="text-base text-slate-300">
    Bastion simulates React component ergonomics <strong>purely using PHP functions</strong> and <strong>HTMX for client interactivity</strong>.
    Two official types:
  </p>

  <h3 class="text-xl font-semibold">1. Server-side components (pure PHP, no HTMX)</h3>
  <p class="text-slate-400 text-sm mb-1">Stateless pieces, used for reusable HTML fragments:</p>
  <pre class="bg-slate-950/80 rounded-xl p-4 text-xs overflow-x-auto"><code>// resources/views/components/UserCard.php
function UserCard(array $user): string {
  return "
  &lt;article class='p-4 border border-slate-700 rounded-xl shadow-lg'&gt;
    &lt;h3&gt;".e($user['name'])."&lt;/h3&gt;
    &lt;p&gt;".e($user['email'])."&lt;/p&gt;
  &lt;/article&gt;";
}</code></pre>

  <p class="text-sm text-slate-400">
    Use case examples:
    <ul class="list-disc list-inside">
      <li>Tables and repeated UI rows</li>
      <li>Email/name cards in dashboards</li>
      <li>Fragments used inside multiple layouts</li>
      <li>Pre-sanitized output using <code>e()</code> ensures XSS safety</li>
    </ul>
  </p>

  <h3 class="text-xl font-semibold">2. Client-side interactive components (HTMX-powered)</h3>
  <p class="text-slate-400 text-sm mb-1">UI that updates without JS:</p>
  <pre class="bg-slate-950/80 rounded-xl p-4 text-xs overflow-x-auto"><code>// resources/views/components/UserRow.php
function UserRow($user) {
  return "
  &lt;tr id='user-{$user['id']}'&gt;
    &lt;td&gt;".e($user['name'])."&lt;/td&gt;
    &lt;td&gt;".e($user['email'])."&lt;/td&gt;
    &lt;td&gt;
      &lt;button 
        hx-delete='/api/users/{$user['id']}' 
        hx-target='#user-{$user['id']}' 
        hx-swap='outerHTML'
        class='px-2 py-1 bg-red-500/10 text-red-400 border border-red-500/40 rounded-md hover:bg-red-500/20'
      &gt;
        Delete
      &lt;/button&gt;
    &lt;/td&gt;
  &lt;/tr&gt;";
}</code></pre>

  <p class="text-sm text-slate-400">
    Use case examples:
    <ul class="list-disc list-inside">
      <li>Live tables reloaded by inspector data</li>
      <li>Buttons that trigger DELETE/PUT endpoints</li>
      <li>Conditional UI (show/hide admin section flags)</li>
      <li>Forms with <code>hx-post</code> + CSRF headers for secure partial updates</li>
    </ul>
  </p>
</section>

<section class="space-y-4" id="api">
  <h2 class="text-3xl font-bold">API Endpoints (FastAPI Style via <code>+server.php</code>)</h2>

  <p class="text-base text-slate-300">
    Endpoints return <strong>method maps</strong> similar to FastAPI route functions. Inside handlers you can use QueryBuilder:
  </p>

  <h3 class="text-xl font-semibold">Example: new API resource endpoint</h3>
  <p class="text-sm text-slate-400">You can create endpoints like <code>app/api/calibrations/+server.php</code>.</p>

  <pre class="bg-slate-950/80 rounded-xl p-4 text-xs overflow-x-auto"><code>&lt;?php
use App\Core\DB;
use App\Core\Response;
use App\Core\ValidationException;

return [
  'get' => function($req) {
    $rows = DB::table('calibrations')->orderBy('created_at','DESC')->get();
    Response::json($rows);
  },

  'post' => function($req) {
    try {
      $data = $req->validate([
        'part_number' => 'required',
        'work_center' => 'required',
      ]);

      $id = DB::table('calibrations')->insert([
        'part_number' => $data['part_number'],
        'work_center' => $data['work_center'],
        'created_at' => time(),
        'created_by' => $GLOBALS['auth_user']['id'] ?? 0,
      ]);

      Response::json(['id'=>$id],201);
    } catch (ValidationException $e) {
      Response::json(['errors'=>$e->errors],422);
    }
  }
];</code></pre>

  <p class="text-xs text-slate-500">
    Note: <code>$req->validate()</code> throws a <code>ValidationException</code> to return 422 errors cleanly. The chain <code>e()</code> ensures safe HTML output on UI.
  </p>
</section>

<!-- TITLES (DV + GLOBALS) -->
<section class="space-y-4">
  <h2 class="text-3xl font-bold" id="titles">Title System and Best Practice</h2>
  <p class="text-sm text-slate-300">
    You can set the HTML title for each route using <strong>DV</strong> or <strong>global variables</strong> for legacy code.<br>
    Because this is a security-first scaffold, the layout defines a <code>fallback</code> that always runs and always sanitizes via <strong>e()</strong>.
  </p>

  <div class="bg-slate-950/60 border border-slate-800 rounded-xl p-3 text-xs text-slate-400">
    <strong>Supported title patterns:</strong>
    <ul class="list-disc list-inside">
      <li><code>DV::set('title', 'Admin · Users')</code> ← recommended, structured, shared across nested layouts</li>
      <li><code>$GLOBALS['title'] = 'Admin · Users'</code> ← legacy, supported, always falls back to DV</li>
    </ul>
  </div>

  <pre class="bg-slate-950/80 rounded-xl p-4 text-xs overflow-x-auto"><code>&lt;?php
// Root layout example (already included by generator)
$title = DV::get('title', $GLOBALS['title'] ?? 'Bastion PHP');
?&gt;
&lt;title&gt;&lt;?= e($title) ?&gt;&lt;/title&gt;</code></pre>
</section>

<!-- COMPONENT CREATION -->
<section class="space-y-4" id="cli">
  <h2 class="text-3xl font-bold">CLI Commands Overview & Workflow</h2>

  <p class="text-base text-slate-300 mb-4">
    Bastion CLI (<code>bastion</code>) includes commands that mimic a mix of Django's manage.py, Artisan feel, and custom scaffolds:
  </p>

  <div class="grid sm:grid-cols-2 lg:grid-cols-3 gap-3 text-xs sm:text-sm">

    <div class="bg-slate-950 border border-slate-800 rounded-xl p-4 shadow-lg space-y-2">
      <p class="font-semibold text-blue-400">run-dev</p>
      <ul class="text-slate-400 space-y-1 list-disc list-inside">
        <li>Starts PHP dev server pointing to <code>public/</code></li>
        <li>Forces CSP nonce regeneration per request</li>
        <li>Errors printed in terminal, never swallowed</li>
        <li>Pairs well with BrowserSync proxy <code>:9876</code></li>
      </ul>
    </div>

    <div class="bg-slate-950 border border-slate-800 rounded-xl p-4">
      <p class="font-semibold text-purple-400">migrate</p>
      <ul class="text-slate-400 space-y-1 list-disc list-inside">
        <li>Reads <code>database/migrations/*.sql</code> in order</li>
        <li>Executes each using PDO + WAL</li>
        <li>No silent fails; stops on SQL errors</li>
      </ul>
    </div>

    <div class="bg-slate-950 border border-slate-800 rounded-xl p-4">
      <p class="font-semibold text-emerald-400">seed</p>
      <ul class="text-slate-400 space-y-1 list-disc list-inside">
        <li>Runs <code>database/seeds/*.php</code></li>
        <li>Perfect for hydrating initial admin/users/parts</li>
        <li>Can be extended to seed multiple modules</li>
      </ul>
    </div>

    <div class="bg-slate-950/60 border border-slate-800 rounded-xl p-4">
      <p class="font-semibold text-yellow-400">key:generate</p>
      <ul class="text-slate-400 space-y-1 list-disc list-inside">
        <li>Generates <code>APP_KEY</code> for the <code>.env</code> file</li>
        <li>Can secure internal encrypt helpers</li>
      </ul>
    </div>

    <div class="bg-slate-950/60 border border-slate-800 rounded-xl p-4">
      <p class="font-semibold text-orange-400">jwt:secret</p>
      <ul class="text-slate-400 space-y-1 list-disc list-inside">
        <li>Regenerates <code>JWT_SECRET</code></li>
        <li>Forces logout of all issued JWTs when rotated</li>
        <li>Important for key compromise recovery</li>
      </ul>
    </div>

  </div>

  <h3 class="text-xl font-semibold mt-6">Extendable code generation commands</h3>
  <p class="text-sm text-slate-400 mb-2">You can add these in future versions:</p>

  <ul class="grid sm:grid-cols-2 lg:grid-cols-3 gap-1 text-xs text-slate-300">
    <li><code>make:page</code> → scaffolds a folder + <code>page.php</code> + optional <code>Client component imports</code></li>
    <li><code>make:api</code> → scaffolds a folder + <code>+server.php</code> with boilerplate GET/POST maps</li>
    <li><code>make:module</code> → scaffolds a high-level folder under <code>app/</code> with default layout stacking enabled</li>
    <li><code>make:component</code> → scaffolds server component or client HTMX component in <code>resources/views/components</code></li>
    <li><code>make:migration</code> → injects a new raw SQL migration with numeric prefix order</li>
    <li><code>make:seed</code> → injects a new seed file</li>
  </ul>
</section>

<!-- ENDPOINT CREATION -->
<section id="endpoint-creation" class="doc-section space-y-4">
  <h2 class="text-3xl font-bold">How to create endpoints (FastAPI-style, ORM-inside)</h2>
  <p class="text-base text-slate-400">
    Endpoints are created by adding folders under <code>app/api/&lt;resource&gt;</code> with a single <code>+server.php</code> file that returns the HTTP method map.
  </p>

  <p class="text-sm text-slate-300">
    The QueryBuilder (<code>DB::table('resource')</code>) can be used directly inside the handler closures to compose SQL-backed queries without writing manual PDO boilerplate.
    Validation lives in the Request object, and responses are standardized with the Response helper.
  </p>
</section>

<!-- RESPONSIVE TAILWIND UI SNIPPET -->
<section id="responsive-snippet" class="doc-section space-y-4">
  <h2 class="text-2xl sm:text-3xl font-bold">Responsive UI using Tailwind CDN</h2>
  <p class="text-sm text-slate-400">
    Because the layout includes Tailwind from CDN, every page can use utility classes like <code>grid</code>, <code>flex</code>, <code>p-*</code>, <code>rounded-*</code>, and responsive prefixes (<code>sm:</code>, <code>lg:</code>, etc) without any extra build step.
  </p>

  <div class="bg-slate-950/40 border border-slate-800 rounded-xl p-4 text-sm text-slate-300">
    <strong>Responsive design tips:</strong>
    <ul class="list-disc list-inside mt-2 text-slate-400 space-y-1">
      <li>Use <code>sm:</code> for mobile-first breakpoints</li>
      <li>Use <code>grid sm:grid-cols-2 lg:grid-cols-3</code> for responsive cards</li>
      <li>Use <code>rounded-2xl shadow-xl p-4 sm:p-6</code> for readable UI</li>
    </ul>
  </div>
</section>

<!-- 100% FINISH -->
<section id="deployment" class="doc-section space-y-4 pb-10">
  <h2 class="text-3xl font-bold">Deployment mindset</h2>
  <p class="text-md text-slate-400">
    Running build would freeze your scaffold for prod entirely.  
    But in dev: YOU see interactive parts with htmx, and server components render raw PHP safely.
  </p>
</section>

</main>
</body>
</html>